---
title: "A simple simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A simple simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=5.5, fig.height=5.5, collapse = TRUE, comment = "##")

# library(flume)
devtools::load_all()
library(igraph)
```

Here we demonstrate the model using a simple simulation with generated data. There are several essential components:

1. A `metacommunity` object, which describes all the possible species that can occur in the simulation, gives their niches, and includes the pairwise competition strength
2. A `river_network`, which describes the topology of the network and gives other important attributes, such as discharge.
3. State variables; these are (mostly) dynamic attributes describing the state of the model at a given time. 
4. Parameters; generally stored in a named list and usually static for the duration of a model run.


They generally take the form of a matrix, with the rows representing locations (i.e., the nodes in the `river_network` object)

A community matrix, one row per site, one column per species, populated with 1s (indicating presence) and 0s (for absence).
2. A state matrix giving important state variables (e.g., resources, habitat); one row per site, one column per variable.





## 1. The metacommunity

The metacommunity is an S3 object created by `flume` that describes all of the species that can possibly occur in the model. It is created using the `metacommunity()` function. Additional species can be added using `species()`, although care should be taken when doing this.

The metacommunity contains a `$species` member, which is a list of `species` objects; each species contains the colonisation and extinction function that defines that species' niche, along with the parameters giving the shapes of those functions. Here we create a 2-species pool that has linear colonisation and constant extinction. The `metacommunity()` function automatically chooses parameters to "spread out" the species in the niche space. We then plot the metacommunity -- the first two panels show the two species' colonisation and extinction functions, and the third shows the dominant eigenvalue (which is positive if the species is expected to be present).

```{r fig.height = 3, fig.width = 7}
sp_pool = metacommunity(n_species = 2, nx = 1, c_type = 'linear', e_type='constant')

par(mfrow=c(1,3))
plot(sp_pool$species[[1]], main = "Species 1")
plot(sp_pool$species[[2]], main = "Species 2")
plot(sp_pool)
```

### 1a. Competition

The `metacommunity()` function automatically handles creating a competition matrix for you. This section explains in more detail how this function is created.

Competition in the model is defined as the degree of overlap between two species' absolute niches, which in turn are defined by the colonisation-extinction functions. This follows from the definition of the absolute niche as the environmental conditions where a species can persist long-term. In a metapopultion, this is predicted to be anywhere $\lambda > 0$, where $\lambda = c - m$. Moreover, the quantity $\lambda$ will be correlated to performance; where $\lambda$ is large, the species will recolonize more quickly after going extinct. We can visualise the niche using the `plot` function.

The model simply computes the area of overlap under the species' niche curves to determine the pairwise competition coefficient, shown shaded in the figure below. This is done using the numerical integration. The more similar two species are, the more their niches overlap, and the larger this shaded area gets. Here, the model has chosen the two species such that they have identical performance (i.e., $\int \lambda_1 = \int \lambda_2$) and competition is minimised.

```{r fig.height = 4, fig.width = 4}
plot(sp_pool)


xpo = seq(0,1,0.05)

# compute the two curves, then choose whichever is smaller
y1 = sp_pool$species[[1]]$col(xpo) - sp_pool$species[[1]]$ext(xpo)
y2 = sp_pool$species[[2]]$col(xpo) - sp_pool$species[[2]]$ext(xpo)
ypo = ifelse(y1 > y2, y2, y1)
ypo = c(ypo, rep(-1, length(ypo)))
xpo = c(xpo, rev(xpo))
polygon(xpo, ypo, border = NA, col = "#d9d9d9")
```

### 1b. Dispersal

The model includes two dispersal parameters `alpha` and `beta`, representing active and passive dispersal, respectively. These are created by default to include no active dispersal and identical passive dispersal among all species. The dispersal parameters can be accessed using the `dispersal_params` function, or by the `alpha` and `beta` members of individual species.

```{r}
dispersal_params(sp_pool)
sp_pool$species[[1]]$beta
```

## 2. The river network

The main component of the river network is a weighted digraph; i.e., the topological relationships between locations. The network graph in `flume` uses stream reaches as nodes, while the edges describe which reaches are neighbours of each other. The simplest way to define a network is using an attribute list and a weighted adjacency matrix.

For attributes, we will use only discharge and cross sectional area (which are required). Other attributes can be specified with a named list, but we will not use them for this example. We use a simple discharge model, where Q grows by 1 each time we move downstream (i.e., when we traverse an edge, representing lateral input), and we add reaches together at confluences. Here, we define node 1 to be the most downstream node (this is purely an arbitrary choice). Although area is a required attribute, if it is omitted when the network is created, then simple hydraulic scaling relationships will be used to estimate area from Q.

```{r}
Q = c(13,12,8,7,1,4,1,1,2,1)
```


The adjacency matrix describes the spatial relationships among nodes. The matrix must be square, with one row and column per node. For two sites `i` and `j`, `adj[i,j]` will be nonzero if `i` is upstream of `j`, and the value indicates the distance between the two. We make all stream reaches the same length for simplicity.

By default, plotting the network will show the edges weighted by discharge. Node ('vertex') colours can be set by `vertex.color`; I use a simple gradient following the order of sites, because this is also how I will set up my resource gradients (in **3. State Variables** below). Edge weight is proportional to the discharge between sites. The layout matrix shows where to plot each vertex; this is optional but can be useful for nicer plots.

```{r fig.height = 5, fig.width = 5}
nsites = length(Q)
adj = matrix(0, nrow=nsites, ncol=nsites)
adj[2,1] = adj[3,2] = adj[9,2] = adj[4,3] = adj[5,4] = adj[6,4] = adj[7,6] = adj[8,6] = adj[10,9] = 1

network = river_network(adjacency = adj, discharge = Q)
layout = matrix(c(0,0,0,1,-0.5,2,-0.5,3,-1,4,0,4,-0.5,5,0.5,5,0.5,2,1,3), byrow=TRUE, nrow=nsites)
plot(network, layout = layout, edge.arrow.size = 0.2)
```



## 3. State Variables

The state variables are a matrix, one row per node in the river network, with each column representing an important
variable for the model (e.g., resources, habitat, etc). The current state of the network can be accessed and updated
with state(). For this example, we use a single state variable representing resources, which we name 'R'.

```{r}
## it's a good idea to name your variables

state(network) = matrix(seq(0, 1, length.out = nsites), ncol=1, dimnames = list(NULL, 'R'))
state(network)
```

Once the state has been set, plotting the network will by default show the state variable with a colour
ramp.

```{r fig.height = 5, fig.width = 5}
plot(network, layout = layout, edge.arrow.size = 0.2)
```




### 3a. Community composition

The other aspect of the river network's state is the community site-by-species matrix. This matrix always has as many rows as there are sites (i.e. nodes) in the river network, and as many columns as there are species in the metacommunity. We can access this variable using the `site_by_species` function, and we can generate one at random using `random_community`. We begin with a two-species, ten-site community matrix, populated at random.

```{r error=TRUE}

## empty, we haven't set it up yet
site_by_species(network)
```

``````{r fig.height = 3, fig.width = 7}
set.seed("5111605")
site_by_species(network) = random_community(network, sp_pool, prevalence = c(0.35, 0.65))
site_by_species(network)

par(mar=rep(0.1, 4))
plot(network, variable = 'site_by_species', layout = layout, edge.arrow.size = 0.2)
```

