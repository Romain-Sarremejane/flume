---
title: "A simple simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A simple simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=5.5, fig.height=5.5, collapse = TRUE, comment = "##")

# library(flume)
devtools::load_all()
library(igraph)
```

Here we demonstrate the model using a simple simulation with generated data. There are several essential components:

1. A community matrix, one row per site, one column per species, populated with 1s (indicating presence) and 0s (for absence).
2. A state matrix giving important state variables (e.g., resources, habitat); one row per site, one column per variable.
3. A species pool, containing the information about the niche of each species in the community
4. A discharge vector with one element per site.
5. A site-by-site adjacency matrix (see below).


## 1. Community matrix

We begin with a two-species, ten-site community matrix, populated at random.

```{r}
set.seed("5111605")

nsites = 10
nsp = 2
comm = matrix(sample(0:1, nsites*nsp, replace=TRUE, prob = c(0.35, 0.65)), ncol=nsp)
comm
```

## 2. State matrix

For simplicity, we use a single state variable, defined as a gradient from 0 to 1 along the 10 sites.

```{r}
n_vars = 1
res = matrix(seq(0, 1, length.out = nsites), ncol=n_vars)

## it's a good idea to name your variables
colnames(res) = c("R")
res
```

## 3. Species Pool

The species pool is an S3 object created by `flume` that describes all of the species in the community. It is created using the `community()` function. Additional species can be added using `species()`, although care should be taken when doing this.

The species pool consists of a list of `species` objects; each species contains the colonisation and extinction function that defines that species' niche, along with the parameters giving the shapes of those functions. Here we create a 2-species pool that has linear colonisation and constant extinction. The `community()` function automatically chooses parameters to "spread out" the species in the niche space. We then plot the community -- the first two panels show the two species' colonisation and extinction functions, and the third shows the dominant eigenvalue (which is positive if the species is expected to be present).

Since we have already defined the state matrix (i.e., the resource concentration at each site), we use this as the `R` argument for the plot methods, so we are viewing each species' performance at our simulated sites.

```{r fig.height = 3, fig.width = 7}
comm = community(n_species = 2, nx = 1, c_type = 'linear', e_type='constant')

par(mfrow=c(1,3))
plot(comm$species[[1]], R=res, main = "Species 1")
plot(comm$species[[2]], R=res, main = "Species 2")
plot(comm, R=res)
```

### 3a. Competition

The `community()` function automatically handles creating a competition matrix for you. This section explains in more detail how this function is created for documentation purposes.

Competition in the model is defined as the degree of overlap between two species' absolute niches, which in turn are defined by the colonisation-extinction functions. This follows from the definition of the absolute niche as the environmental conditions where a species can persist long-term. In a metapopultion, this is predicted to be anywhere $\lambda > 0$, where $\lambda = c - m$. Moreover, the quantity $\lambda$ will be correlated to performance; where $\lambda$ is large, the species will recolonize more quickly after going extinct. We can visualise the niche using the `plot.community` function.

The model simply computes the area of overlap under the species' niche curves to determine the pairwise competition coefficient, shown shaded in the figure below. This is done using the integrate function in R. The more similar two species are, the more their niches overlap, and the larger this shaded area gets. Here, the model has chosen the two species such that they have identical performance (i.e., $\int \lambda_1 = \int \lambda_2$) and competition is minimised.

```{r fig.height = 4, fig.width = 4}
plot(comm, R=res)


xpo = seq(0,1,0.05)

# compute the two curves, then choose whichever is smaller
y1 = comm$species[[1]]$col(xpo) - comm$species[[1]]$ext(xpo)
y2 = comm$species[[2]]$col(xpo) - comm$species[[2]]$ext(xpo)
ypo = ifelse(y1 > y2, y2, y1)
ypo = c(ypo, rep(-1, length(ypo)))
xpo = c(xpo, rev(xpo))
polygon(xpo, ypo, border = NA, col = "#d9d9d9")
```

## 4. Discharge

We use a very simple model for discharge, growing from upstream to downstream; Q grows by 1 each time we move downstream, and we add reaches together at confluences. See the plot of the adjacency matrix below for details.

```{r}
Q = c(13,12,8,7,1,4,1,1,2,1)
```



## 5. Adjacency matrix

The adjacency matrix describes the structure of the river network and how the different sites are connected to one another. The matrix must be square, with one row and column per site. For two sites `i` and `j`, `adj[i,j]` will be nonzero if `i` is downstream of `j`, and the value indicates the distance between the two.

We set the same distance for all connections here for simplicity.

Edge weight is proportional to the discharge between sites. Vertex color is proportional to the value of the environmental gradient at each site.

```{r fig.height = 5, fig.width = 5}
adj = matrix(0, nrow=nsites, ncol=nsites)
adj[1,2] = adj[2,3] = adj[2,9] = adj[3,4] = adj[4,5] = adj[4,6] = adj[6,7] = adj[6,8] = adj[9,10] = 1
layout = matrix(c(0,0,0,1,-0.5,2,-0.5,3,-1,4,0,4,-0.5,5,0.5,5,0.5,2,1,3), byrow=TRUE, nrow=nsites)
plt = graph_from_adjacency_matrix(t(adj), mode = "directed")
vcols = colorRampPalette(c("#f7fcfd", "#00441b"))(nsites)
plot(plt, vertex.color=vcols, edge.color="#a6bddb", edge.arrow.size=0.3, layout = layout, edge.width = Q[2:nsites])
```




## old stuff, update


The parameter list will need to have named elements corresponding to parameters in the model. Additional parameters that are required for (for example) colonisation and extinction functions should also be provided in this list. Parameters generally should have one entry per species, or, if they are shared among species, a single entry.

* alpha: active dispersal; we use only passive dispersal here, so set to zero for all species.
* beta: passive dispersal; we give species two double the dispersal rate.
* gamma: Competition matrix, a square matrix giving the strength of competition. Negative values can be used to indicate facilitation.

```{r}
params = list(
	alpha = 0, 
	beta = c(0.5,1),
	gamma = matrix(c(0,1,1,0), ncol=nsp)
)
```


